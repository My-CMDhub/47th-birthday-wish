<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happy 47th Birthday - A Cinematic Experience</title>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;700&display=swap" rel="stylesheet">
    
    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/@studio-freight/lenis@1.0.42/dist/lenis.min.js"></script>
    
    <style>
        /* ============= GLOBAL STYLES ============= */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            scroll-behavior: smooth;
        }
        
        body {
            font-family: 'Space Grotesk', sans-serif;
            background: #000;
            color: white;
            overflow-x: hidden;
        }
        
        /* ============= SECTION MANAGEMENT ============= */
        .section {
            position: relative;
            width: 100%;
            opacity: 0;
            transition: opacity 0.8s ease-in-out;
        }
        
        .section.active {
            opacity: 1;
        }
        
        /* ============= HERO SECTION STYLES ============= */
        .hero-section {
            height: 100vh;
            background: white;
            position: relative;
            overflow: hidden;
        }
        
        /* Hero Animations */
        @keyframes sweep-block-top-left {
            0% { transform: translate(-100%, -100%) scale(1); opacity: 0; }
            50% { transform: translate(-5%, -5%) scale(1.02); opacity: 1; }
            100% { transform: translate(0, 0) scale(1); opacity: 1; }
        }
        
        @keyframes sweep-block-top-right {
            0% { transform: translate(100%, -100%) scale(1); opacity: 0; }
            50% { transform: translate(5%, -5%) scale(1.02); opacity: 1; }
            100% { transform: translate(0, 0) scale(1); opacity: 1; }
        }
        
        @keyframes sweep-block-bottom-left {
            0% { transform: translate(-100%, 100%) scale(1); opacity: 0; }
            50% { transform: translate(-5%, 5%) scale(1.02); opacity: 1; }
            100% { transform: translate(0, 0) scale(1); opacity: 1; }
        }
        
        @keyframes sweep-block-bottom-right {
            0% { transform: translate(100%, 100%) scale(1); opacity: 0; }
            50% { transform: translate(5%, 5%) scale(1.02); opacity: 1; }
            100% { transform: translate(0, 0) scale(1); opacity: 1; }
        }
        
        @keyframes letter-emerge {
            0% { transform: translateY(-50px); opacity: 0; }
            70% { transform: translateY(10px); opacity: 1; }
            100% { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes laser-stripe-vertical {
            0% { transform: translateY(-100vh) scaleY(0); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translateY(0) scaleY(1); opacity: 0; }
        }
        
        @keyframes laser-stripe-horizontal {
            0% { transform: translateX(-100vw) scaleX(0); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translateX(0) scaleX(1); opacity: 0; }
        }
        
        @keyframes laser-stripe-diagonal {
            0% { transform: translate(-100vw, -100vh) rotate(45deg) scale(0); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translate(0, 0) rotate(45deg) scale(1); opacity: 0; }
        }
        
        /* Hero Classes */
        .animate-sweep-block-top-left { animation: sweep-block-top-left 2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; animation-delay: 1s; }
        .animate-sweep-block-top-right { animation: sweep-block-top-right 2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; animation-delay: 1s; }
        .animate-sweep-block-bottom-left { animation: sweep-block-bottom-left 2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; animation-delay: 1s; }
        .animate-sweep-block-bottom-right { animation: sweep-block-bottom-right 2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; animation-delay: 1s; }
        
        .letter {
            display: inline-block;
            opacity: 0;
            animation: letter-emerge 1s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            cursor: pointer;
        }
        
        .letter:hover { transform: translateY(-8px); }
        .letter:nth-child(even):hover { transform: translateY(8px); }
        
        .laser-stripe-vertical {
            position: absolute; top: 0; left: 20%; width: 2px; height: 100vh;
            background: linear-gradient(to bottom, transparent, #00ffff, transparent);
            box-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
            animation: laser-stripe-vertical 0.8s ease-out forwards; animation-delay: 3.5s; opacity: 0;
        }
        
        .laser-stripe-horizontal {
            position: absolute; top: 30%; left: 0; width: 100vw; height: 2px;
            background: linear-gradient(to right, transparent, #ff00ff, transparent);
            box-shadow: 0 0 20px #ff00ff, 0 0 40px #ff00ff;
            animation: laser-stripe-horizontal 0.8s ease-out forwards; animation-delay: 3.7s; opacity: 0;
        }
        
        .laser-stripe-diagonal {
            position: absolute; top: 0; left: 0; width: 2px; height: 141vh;
            background: linear-gradient(to bottom, transparent, #ffff00, transparent);
            box-shadow: 0 0 20px #ffff00, 0 0 40px #ffff00;
            animation: laser-stripe-diagonal 1s ease-out forwards; animation-delay: 3.9s; opacity: 0;
            transform-origin: 0 0;
        }
        
        .hero-title {
            font-size: clamp(1.8rem, 7vw, 7.5rem);
            line-height: 1.06;
            text-align: center;
        }
        
        .hero-line {
            display: inline-flex;
            align-items: baseline;
            flex-wrap: nowrap;
            gap: 0.35em;
            white-space: nowrap;
        }
        
        .number-group { position: relative; display: inline-block; }
        .number-group .sup-th {
            position: absolute; right: -0.08em; top: -0.85em;
            font-size: 0.28em; line-height: 1;
        }
        
        
        /* ============= SECOND SECTION STYLES ============= */
        .second-section {
            height: 100vh;
            background: #000;
            position: relative;
            overflow: hidden;
        }
        
        .father-overlay {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 16px 24px;
            text-align: center;
            z-index: 30;
            opacity: 0;
            transform: translateX(-50%) translateY(20px);
            transition: all 1s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            min-width: 280px;
        }
        
        .father-overlay.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
        
        .father-overlay .heart {
            font-size: 24px;
            color: #ff6b6b;
            animation: heartbeat 2s ease-in-out infinite;
            display: inline-block;
            margin-bottom: 8px;
        }
        
        .father-overlay .message {
            color: white;
            font-size: 14px;
            font-weight: 400;
            line-height: 1.4;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
        }
        
        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            20% { transform: scale(1.1); }
            40% { transform: scale(1); }
            60% { transform: scale(1.05); }
            80% { transform: scale(1); }
        }
        
        @keyframes split {
            0% { transform: translateY(0); opacity: 1; }
            40% { transform: translateY(-100%); opacity: 1; }
            100% { transform: translateY(-100%); opacity: 0; }
        }
        
        @keyframes split-reverse {
            0% { transform: translateY(0); opacity: 1; }
            40% { transform: translateY(100%); opacity: 1; }
            100% { transform: translateY(100%); opacity: 0; }
        }
        
        @keyframes reveal-image {
            0% { filter: blur(30px); opacity: 0.3; transform: scale(1.1); }
            40% { filter: blur(0px); opacity: 1; transform: scale(1); }
            100% { filter: blur(0px); opacity: 1; transform: scale(1); }
        }
        
        @keyframes text-fade-out {
            0% { opacity: 1; }
            20% { opacity: 0; }
            100% { opacity: 0; visibility: hidden; }
        }

        .animate-split { animation: split 4s forwards; }
        .animate-split-reverse { animation: split-reverse 4s forwards; }
        .animate-reveal-image { animation: reveal-image 4s forwards; }
        .animate-text-fade-out { animation: text-fade-out 2s forwards; }

        /* Second section trigger classes */
        .second-section.active .second-text-fade { animation: text-fade-out 2s forwards; }

        /* Ensure text stays permanently hidden after fade-out animation completes */
        .second-text-fade {
            transition: none; /* Remove any transitions that might interfere */
        }

        .second-text-fade.faded-out {
            opacity: 0 !important;
            visibility: hidden !important;
            pointer-events: none !important;
        }
        .second-section.active .second-split-top { animation: split 4s forwards; }
        .second-section.active .second-split-bottom { animation: split-reverse 4s forwards; }
        .second-section.active .second-image-reveal { animation: reveal-image 4s forwards; }
        .second-section.active .father-overlay { 
            animation-delay: 4.5s; 
            animation: father-overlay-show 1s 4.5s forwards; 
        }
        
        @keyframes father-overlay-show {
            0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
            100% { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        
        /* ============= THIRD SECTION STYLES ============= */
        .third-section {
            height: 400vh;
            background: #000;
            position: relative;
        }
        
        .webgl {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            outline: none;
            z-index: 1;
        }
        
        /* ============= FOURTH SECTION STYLES ============= */
        .fourth-section {
            height: 200vh;
            background: #000;
            position: relative;
            overflow: hidden;
        }
        
        /* Animated gradient variables */
        @property --g1-1-x { syntax: "<percentage>"; inherits: false; initial-value: 20%; }
        @property --g1-1-y { syntax: "<percentage>"; inherits: false; initial-value: 80%; }
        @property --g1-2-x { syntax: "<percentage>"; inherits: false; initial-value: 80%; }
        @property --g1-2-y { syntax: "<percentage>"; inherits: false; initial-value: 20%; }
        
        .gradient-bg {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 0; pointer-events: none;
            background:
                radial-gradient(100% 100% at var(--g1-1-x) var(--g1-1-y), rgba(0,140,255,0.16) 0%, transparent 55%),
                radial-gradient(100% 100% at var(--g1-2-x) var(--g1-2-y), rgba(255,60,130,0.14) 0%, transparent 60%),
                linear-gradient(180deg, #060606 0%, #000 100%);
            background-repeat: no-repeat; background-size: 120% 120%, 120% 120%, 100% 100%;
            filter: saturate(120%); animation: g-1 18s infinite ease-in-out;
        }
        
        @keyframes g-1 {
            0% { --g1-1-x: 20%; --g1-1-y: 80%; --g1-2-x: 80%; --g1-2-y: 20%; }
            25% { --g1-1-x: 15%; --g1-1-y: 15%; --g1-2-x: 85%; --g1-2-y: 80%; }
            50% { --g1-1-x: 80%; --g1-1-y: 15%; --g1-2-x: 15%; --g1-2-y: 85%; }
            75% { --g1-1-x: 40%; --g1-1-y: 70%; --g1-2-x: 70%; --g1-2-y: 30%; }
            100% { --g1-1-x: 20%; --g1-1-y: 80%; --g1-2-x: 80%; --g1-2-y: 20%; }
        }
        
        .letterbox-top, .letterbox-bottom {
            position: absolute; left: 0; width: 100%; height: 50%; background: #000; z-index: 10;
            transition: height 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        .letterbox-top { top: 0; }
        .letterbox-bottom { bottom: 0; }
        
        .tv-card {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9);
            width: 90%; max-width: 1200px; aspect-ratio: 16/9; opacity: 0;
            transition: all 2.5s cubic-bezier(0.25, 0.46, 0.45, 0.94); transition-delay: 0.2s;
        }
        
        .video-container {
            position: relative; width: 100%; height: 100%; border-radius: 12px; overflow: hidden;
            background: #000; box-shadow: inset 0 0 30px rgba(0,0,0,0.8);
        }
        
        .video-overlay {
            position: absolute; left: 50%; bottom: 8%; transform: translateX(-50%);
            background: rgba(0,0,0,0.45);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 16px; padding: 14px 18px;
            color: #fff; text-align: center; z-index: 3;
            opacity: 0; filter: none; pointer-events: none;
            transition: opacity 0.9s ease 0.6s, transform 0.9s ease 0.6s;
            transform-origin: center;
        }

        .video-overlay.show { opacity: 1; transform: translateX(-50%) translateY(0); }

        .video-overlay .line {
            font-size: 14px; letter-spacing: 0.2px; line-height: 1.35; white-space: nowrap;
        }

        .video-overlay .heart { display: inline-block; margin-left: 6px; animation: heart-pulse 1.8s ease-in-out infinite; }

        @keyframes heart-pulse {
            0%, 100% { transform: scale(1); }
            35% { transform: scale(1.15); }
            65% { transform: scale(1.05); }
        }

        .video-screen {
            width: 100%; height: 100%; object-fit: cover; opacity: 0;
            transition: opacity 1s ease-in-out; transition-delay: 0.6s;
        }
        
        .sound-toggle {
            position: absolute; right: 14px; bottom: 14px; z-index: 4;
            background: rgba(0,0,0,0.45); color: #fff; border: 1px solid rgba(255,255,255,0.2);
            border-radius: 999px; padding: 8px 12px; cursor: pointer; font-size: 14px;
            transition: transform 0.2s ease, background 0.2s ease;
        }
        .sound-toggle:hover { transform: scale(1.05); background: rgba(0,0,0,0.6); }

        /* Follow-cursor prompt state before first interaction */
        .sound-toggle.follow {
            right: auto; bottom: auto; left: var(--fx, 50%); top: var(--fy, 50%);
            transform: translate(-50%, -50%);
            padding: 12px 14px; font-size: 16px;
            background: rgba(0,0,0,0.55);
            animation: pulse 1.6s ease-in-out infinite;
        }
        @keyframes pulse { 0%,100%{ box-shadow: 0 0 0 0 rgba(255,255,255,.25);} 50%{ box-shadow: 0 0 0 10px rgba(255,255,255,0);} }

        .ambient-glow {
            position: absolute; top: -20px; left: -20px; right: -20px; bottom: -20px;
            background: radial-gradient(ellipse at center, rgba(255,255,255,0.1) 0%, transparent 70%);
            border-radius: 40px; animation: gentle-pulse 3s ease-in-out infinite;
        }
        
        @keyframes gentle-pulse {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.02); }
        }
        
        /* Animation triggers for fourth section */
        .fourth-section.animate .letterbox-top { height: 0; }
        .fourth-section.animate .letterbox-bottom { height: 0; }
        .fourth-section.animate .tv-card { opacity: 1; transform: translate(-50%, -50%) scale(1.15); }
        .fourth-section.animate .video-screen { opacity: 1; }

        /* Heading over the section (top) */
        .video-heading {
            position: absolute; top: 6%; left: 50%; transform: translateX(-50%) translateY(-10px);
            margin: 0; padding: 10px 16px; border-radius: 14px;
            color: white; text-align: center; z-index: 20; opacity: 0;
            background: rgba(0,0,0,0.25); border: 1px solid rgba(255,255,255,0.15);
            font-weight: 600; letter-spacing: 0.3px; line-height: 1.2;
            font-size: clamp(20px, 3.6vw, 44px);
            transition: opacity 0.8s ease 0.3s, transform 0.8s ease 0.3s;
        }

        .fourth-section.animate .video-heading { opacity: 1; transform: translateX(-50%) translateY(0); }
        
        /* ============= FINAL SECTION STYLES ============= */
        .final-section {
            height: 800vh;
            background: #000;
            position: relative;
        }
        
        .shader-canvas {
            position: fixed;
            top: 0;
            left: 0;
            display: block;
            z-index: 1;
        }
        
        .slider-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            perspective: 1000px; z-index: 2; pointer-events: none;
        }
        
        .slide {
            position: absolute; width: 400px; height: 500px;
            will-change: transform, opacity, scale; padding: 15px;
            background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px; opacity: 0;
            cursor: pointer; transition: all 0.3s ease;
            perspective: 1000px; pointer-events: auto;
        }
        
        /* Clear backdrop for centered cards */
        .slide.centered {
            background: transparent !important;
            backdrop-filter: none !important;
            border: none !important;
        }
        
        
        .slide-inner {
            position: relative; width: 100%; height: 100%;
            transform-style: preserve-3d; transition: transform 0.8s ease;
        }
        
        .slide.flipped .slide-inner {
            transform: rotateY(180deg);
        }
        
        .slide-front, .slide-back {
            position: absolute; width: 100%; height: 100%;
            backface-visibility: hidden; border-radius: 5px;
        }
        
        .slide-front img {
            width: 100%; height: 100%; object-fit: cover; border-radius: 5px;
        }
        
        .slide-back {
            transform: rotateY(180deg);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; padding: 20px; color: white;
        }
        
        /* Unique gradient backgrounds for each card */
        .slide[data-wish="0"] .slide-back { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .slide[data-wish="1"] .slide-back { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .slide[data-wish="2"] .slide-back { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
        .slide[data-wish="3"] .slide-back { background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); }
        .slide[data-wish="4"] .slide-back { background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); }
        .slide[data-wish="5"] .slide-back { background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); }
        
        .wish-icon {
            font-size: 4rem; margin-bottom: 1.5rem;
            color: #FFD700;
            filter: drop-shadow(0 4px 12px rgba(255, 215, 0, 0.8));
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
        }
        
        .wish-text {
            font-size: 1.3rem; line-height: 1.7; font-weight: 400;
            color: #FFFFFF;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.9);
            margin-bottom: 1.5rem;
            font-family: 'Space Grotesk', sans-serif;
        }
        
        .wish-signature {
            font-size: 1.1rem; margin-top: 1rem; 
            font-style: italic; font-weight: 500;
            color: #FFFFFF;
            text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.8);
        }
        
        /* Card centering animation */
        .slide.centered {
            position: fixed !important;
            top: 50% !important; left: 50% !important;
            transform: translate(-50%, -50%) scale(1.2) !important;
            z-index: 1000; opacity: 1 !important;
            transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) !important;
            background: transparent !important;
            backdrop-filter: none !important;
            border: none !important;
            box-shadow: 0 20px 60px rgba(255, 255, 255, 0.1) !important;
        }
        
        /* Backdrop when card is centered */
        .card-backdrop {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.1); z-index: 999; opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        
        .card-backdrop.active {
            opacity: 1; pointer-events: auto;
        }
        
        /* ============= LAST FINAL SECTION STYLES ============= */
        .last-final-section {
            height: 100vh;
            background: #0b0b0d;
            position: relative;
            overflow: hidden;
        }
        
        .fireworks-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        
        /* ============= SCROLL PROGRESS INDICATOR ============= */
        .scroll-progress {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            z-index: 1000;
        }
        
        .scroll-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff00ff, #00ffff, #ffff00);
            width: 0%;
            transition: width 0.1s ease;
        }

        /* ============= SCROLL INDICATOR ============= */
        .scroll-indicator {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            opacity: 1;
            transition: opacity 0.8s ease;
            pointer-events: none;
        }

        .scroll-indicator.hidden {
            opacity: 0;
        }

        .scroll-arrow {
            width: 24px;
            height: 24px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-top: none;
            border-left: none;
            transform: rotate(45deg);
            animation: scroll-bounce 2s ease-in-out infinite;
        }

        .scroll-text {
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            text-align: center;
            margin-top: 8px;
            font-weight: 300;
            letter-spacing: 0.5px;
        }

        @keyframes scroll-bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: rotate(45deg) translateY(0);
            }
            40% {
                transform: rotate(45deg) translateY(-8px);
            }
            60% {
                transform: rotate(45deg) translateY(-4px);
            }
        }
        
        /* ============= BIRTHDAY MESSAGE STYLES ============= */
        @keyframes fade-in {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        
        .animate-fade-in {
            animation: fade-in 1s ease-out;
        }
        
        .birthday-message {
            text-align: center;
            margin-top: 2rem;
        }
        
        .birthday-message p {
            margin-bottom: 1rem;
        }
        
        /* ============= RESPONSIVE DESIGN ============= */
        @media (max-width: 768px) {
            .hero-line { gap: 0.22em; }
            .tv-card { width: 90%; }
            .slide { width: 300px; height: 400px; }
        }
    </style>
</head>
<body>
    <!-- Scroll Progress Indicator -->
    <div class="scroll-progress">
        <div class="scroll-progress-bar" id="scrollProgressBar"></div>
    </div>

    <!-- Scroll Indicator -->
    <div class="scroll-indicator" id="scrollIndicator">
        <div class="scroll-arrow"></div>
        <div class="scroll-text">Scroll to explore</div>
    </div>

    <!-- ============= HERO SECTION ============= -->
    <section id="hero" class="section hero-section active">
        <div class="absolute top-0 left-0 w-full h-full overflow-hidden">
            <!-- Four Corner Black Blocks that sweep and merge -->
            <div class="absolute top-0 left-0 w-1/2 h-1/2 bg-black animate-sweep-block-top-left"></div>
            <div class="absolute top-0 right-0 w-1/2 h-1/2 bg-black animate-sweep-block-top-right"></div>
            <div class="absolute bottom-0 left-0 w-1/2 h-1/2 bg-black animate-sweep-block-bottom-left"></div>
            <div class="absolute bottom-0 right-0 w-1/2 h-1/2 bg-black animate-sweep-block-bottom-right"></div>

            <!-- Laser Stripe Effects -->
            <div class="laser-stripe-vertical"></div>
            <div class="laser-stripe-horizontal"></div>
            <div class="laser-stripe-diagonal"></div>
        </div>
        
        <div class="absolute inset-0 flex flex-col items-center justify-center" style="z-index: 100;">
            <h1 class="text-white hero-title font-bold uppercase tracking-[0.2em]" style="font-family: 'Space Grotesk', sans-serif;">
                <span class="hero-line">
                    <span class="letter" data-text="R" style="animation-delay: 2.5s;">R</span>
                    <span class="letter" data-text="E" style="animation-delay: 2.6s;">E</span>
                    <span class="letter" data-text="A" style="animation-delay: 2.7s;">A</span>
                    <span class="letter" data-text="D" style="animation-delay: 2.8s;">D</span>
                    <span class="letter" data-text="Y" style="animation-delay: 2.9s;">Y</span>
                    <span style="width: 0.6em;"></span>
                    <span class="letter" data-text="F" style="animation-delay: 3.05s;">F</span>
                    <span class="letter" data-text="O" style="animation-delay: 3.1s;">O</span>
                    <span class="letter" data-text="R" style="animation-delay: 3.15s;">R</span>
                </span>
            </h1>
            <h2 class="text-white hero-title font-bold uppercase tracking-[0.2em] mt-6" style="font-family: 'Space Grotesk', sans-serif;">
                <span class="hero-line">
                    <span class="number-group">
                        <span class="letter" data-text="4" style="animation-delay: 3.25s;">4</span>
                        <span class="letter" data-text="7" style="animation-delay: 3.3s;">7</span>
                        <span class="sup-th letter" data-text="th" style="animation-delay: 3.34s;">th</span>
                    </span>
                    <span style="width: 0.8em;"></span>
                    <span class="letter" data-text="B" style="animation-delay: 3.4s;">B</span>
                    <span class="letter" data-text="I" style="animation-delay: 3.45s;">I</span>
                    <span class="letter" data-text="R" style="animation-delay: 3.5s;">R</span>
                    <span class="letter" data-text="T" style="animation-delay: 3.55s;">T</span>
                    <span class="letter" data-text="H" style="animation-delay: 3.6s;">H</span>
                    <span class="letter" data-text="D" style="animation-delay: 3.65s;">D</span>
                    <span class="letter" data-text="A" style="animation-delay: 3.7s;">A</span>
                    <span class="letter" data-text="Y" style="animation-delay: 3.75s;">Y</span>
                </span>
            </h2>

            <!-- Personalized birthday message -->
            <div class="birthday-message mt-8">
                <p class="text-white/80 text-lg md:text-xl font-light tracking-wide animate-fade-in"
                   style="animation-delay: 4s; animation-fill-mode: both;">
                    Celebrating an extraordinary father, mentor, and inspiration
                </p>
                <p class="text-white/60 text-sm md:text-base font-light mt-2 animate-fade-in"
                   style="animation-delay: 4.5s; animation-fill-mode: both;">
                    May this year bring you endless joy, success, and cherished moments
                </p>
            </div>
        </div>
    </section>

    <!-- ============= SECOND SECTION ============= -->
    <section id="second" class="section second-section">
        <!-- Text that fades out -->
        <div class="absolute inset-0 z-20 flex items-center justify-center second-text-fade">
            <div class="text-center">
                <h1 class="text-white text-6xl md:text-8xl lg:text-9xl font-bold tracking-wider mb-4">
                    HAPPY BIRTHDAY
                </h1>
                <p class="text-white/70 text-lg md:text-xl font-light tracking-wide">
                    Celebrating another amazing year of your incredible journey
                </p>
            </div>
        </div>

        <!-- Split screen animations -->
        <div class="absolute top-0 left-0 w-full h-1/2 bg-black z-10 second-split-top"></div>
        <div class="absolute bottom-0 left-0 w-full h-1/2 bg-black z-10 second-split-bottom"></div>

        <!-- Image reveal -->
        <div class="absolute inset-0 flex items-center justify-center second-image-reveal">
            <img
                alt="Portrait celebration"
                class="h-full w-full object-cover"
                src="./3D Models/Pattern_01/default_cloth.png"
            />
        </div>
        
        <!-- Father overlay message -->
        <div class="father-overlay">
            <div class="heart">‚ù§Ô∏è</div>
            <div class="message">The most wonderful father, mentor, and inspiration in our lives</div>
        </div>
    </section>

    <!-- ============= THIRD SECTION ============= -->
    <section id="third" class="section third-section">
        <canvas class="webgl" id="thirdCanvas"></canvas>
    </section>

    <!-- ============= FOURTH SECTION ============= -->
    <section id="fourth" class="section fourth-section">
        <!-- Premium animated gradient background -->
        <div class="gradient-bg"></div>
        
        <!-- Heading at the top -->
        <h3 class="video-heading">Let‚Äôs sit back and enjoy these beautiful moments together ‚ù§Ô∏è</h3>
        
        <!-- Letterbox bars -->
        <div class="letterbox-top"></div>
        <div class="letterbox-bottom"></div>
        
        <!-- Premium Glass TV Card -->
        <div class="tv-card">
            <div class="ambient-glow"></div>
            <div class="video-container">
                <!-- Replace this video src with your birthday video -->
                <video class="video-screen"
                       muted
                       autoplay
                       playsinline
                       preload="metadata"
                       loop
                       poster="./Thumbnail/Thumbnail.png"
                       webkit-playsinline
                       x-webkit-airplay="allow"
                       disablePictureInPicture>
                    <source src="./Video/Birthday_vid.mp4" type="video/mp4">
                    <p>Your browser doesn't support HTML5 video. Here is a <a href="./Video/Birthday_vid.mp4">link to the video</a> instead.</p>
                </video>
                <!-- Sweet minimal overlay -->
                
                <!-- Sound toggle -->
                <button id="soundToggle" class="sound-toggle" aria-label="Toggle sound" title="Toggle sound">üîá</button>
            </div>
        </div>
    </section>

    <!-- ============= FINAL SECTION ============= -->
    <section id="final" class="section final-section">
        <!-- The canvas for our shader background -->
        <canvas id="shader-canvas" class="shader-canvas"></canvas>

        <!-- The HTML elements for the images -->
        <div class="slider-container" id="finalSliderContainer"></div>
        
        <!-- Card backdrop for centering effect -->
        <div class="card-backdrop" id="cardBackdrop"></div>
    </section>

    <!-- ============= LAST FINAL SECTION ============= -->
    <section id="last-final" class="section last-final-section">
        <canvas id="fireworks-canvas" class="fireworks-canvas"></canvas>
    </section>

    <script>
        // ============= GLOBAL VARIABLES ============= 
        let currentSectionIndex = 0;
        const sections = document.querySelectorAll('.section');
        let isScrolling = false;
        let scrollTimeout;
        
        // ============= SMOOTH SCROLLING SETUP =============
        const lenis = new Lenis({
            duration: 1.8,
            easing: (t) => 1 - Math.pow(1 - t, 3), // Smoother cubic easing
            direction: 'vertical',
            gestureDirection: 'vertical',
            smooth: true,
            mouseMultiplier: 0.8, // Reduced for smoother feel
            smoothTouch: true, // Enable for better mobile experience
            touchMultiplier: 1.5,
            infinite: false,
            wrapper: window,
            content: document.documentElement,
            lerp: 0.08, // Smoother interpolation
        });

        function raf(time) {
            lenis.raf(time);
            requestAnimationFrame(raf);
        }
        requestAnimationFrame(raf);

        // ============= SCROLL PROGRESS =============
        function updateScrollProgress() {
            const scrollTop = window.pageYOffset;
            const docHeight = document.documentElement.scrollHeight - window.innerHeight;
            const scrollPercent = (scrollTop / docHeight) * 100;
            document.getElementById('scrollProgressBar').style.width = scrollPercent + '%';
        }

        // ============= SCROLL INDICATOR =============
        function updateScrollIndicator() {
            const scrollIndicator = document.getElementById('scrollIndicator');
            const scrollTop = window.pageYOffset;
            
            // Hide scroll indicator after user scrolls down a bit
            if (scrollTop > 50) {
                scrollIndicator.classList.add('hidden');
            } else {
                scrollIndicator.classList.remove('hidden');
            }
        }

        // ============= SECTION MANAGEMENT =============
        let sectionBounds = [];
        
        function calculateSectionBounds() {
            sectionBounds = Array.from(sections).map(section => ({
                top: section.offsetTop,
                bottom: section.offsetTop + section.offsetHeight
            }));
        }
        
        function updateActiveSection() {
            const scrollY = window.scrollY;
            const windowHeight = window.innerHeight;
            const trigger = scrollY + windowHeight * 0.5;
            
            for (let i = 0; i < sectionBounds.length; i++) {
                if (trigger >= sectionBounds[i].top && trigger < sectionBounds[i].bottom) {
                    if (currentSectionIndex !== i) {
                        currentSectionIndex = i;
                        activateSection(i);
                    }
                    break;
                }
            }
        }

        function activateSection(index) {
            sections.forEach((section, i) => {
                if (i === index) {
                    section.classList.add('active');
                    triggerSectionAnimation(section, i);
                } else {
                    section.classList.remove('active');
                }
            });
        }

        function triggerSectionAnimation(section, index) {
            switch(index) {
                case 0: // Hero
                    initHeroAnimations();
                    break;
                case 1: // Second
                    initSecondAnimations();
                    break;
                case 2: // Third
                    initThirdAnimations();
                    break;
                case 3: // Fourth
                    initFourthAnimations();
                    break;
                case 4: // Final
                    initFinalAnimations();
                    break;
                case 5: // Last Final
                    initLastFinalAnimations();
                    break;
            }
        }

        // ============= HERO SECTION ANIMATIONS =============
        function initHeroAnimations() {
            console.log('Hero animations started');
            // Letter animations are now handled purely by CSS with animation-delay
        }

        // ============= SECOND SECTION ANIMATIONS =============
        function initSecondAnimations() {
            console.log('Second section animations started');

            // Find the text element and ensure it stays hidden after animation
            const textElement = document.querySelector('.second-text-fade');
            if (textElement) {
                // Add the faded-out class after the animation completes (2 seconds)
                setTimeout(() => {
                    textElement.classList.add('faded-out');
                }, 2000);
            }

            // Animations are CSS-based and will trigger automatically
        }

        // ============= THIRD SECTION ANIMATIONS =============
        function initThirdAnimations() {
            console.log('Third section animations started');
            
            const canvas = document.getElementById('thirdCanvas');
            if (!canvas || canvas.threeInitialized) return;
            
            canvas.threeInitialized = true;

            // --- IMAGE LOADING ---
            const imageSources = [
                // Existing patterns
                './3D Models/Pattern_01/Black_cloth.png',
                './3D Models/Pattern_02/Bckground_look01.png',
                './3D Models/Pattern_01/default_cloth.png',
                './3D Models/Pattern_02/Bckground_look02.png',
                './3D Models/Pattern_01/Gray_cloth.png',
                './3D Models/Pattern_02/Bckground_look03.png',
                './3D Models/Pattern_01/Green_cloth.png',
                './3D Models/Pattern_02/Bckground_look04.png',
                './3D Models/Pattern_01/Red_cloth.png',
                './3D Models/Pattern_02/Bckground_look05.png',
                './3D Models/Pattern_01/White_cloth.png',
               
               
               
                
               
            ];

            const images = [];
            let imagesLoaded = 0;

            const initSlider = () => {
                // --- THREE.JS SCENE SETUP ---
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: true,
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

                // --- GEOMETRY & CURVATURE ---
                const geometryWidth = 12; // reduced width
                const geometryHeight = 80;
                const verticalCurvature = 20;
                const horizontalCurvature = 15;
                const segments = 200;

                const geometry = new THREE.PlaneGeometry(geometryWidth, geometryHeight, segments, segments);
                const originalPositions = new Float32Array(geometry.attributes.position.array);
                const curvedPositions = new Float32Array(originalPositions);

                // Pre-calculate the fully curved state
                for (let i = 0; i < originalPositions.length; i += 3) {
                    const x = originalPositions[i];
                    const y = originalPositions[i + 1];
                    const zVertical = -(y * y) / verticalCurvature;
                    const zHorizontal = -(x * x) / horizontalCurvature;
                    curvedPositions[i + 2] = zVertical + zHorizontal;
                }

                // --- DYNAMIC TEXTURE ON A CANVAS ---
                const slides = imageSources.length;
                const slideHeight = 600; // increased for taller images
                const slideGap = 60;     // increased spacing between slides
                const textureHeight = 16000; // accommodate larger layout
                // Match texture width to geometry aspect ratio for proper image display
                const textureWidth = Math.floor(textureHeight * (geometryWidth / geometryHeight)); 

                const textureCanvas = document.createElement('canvas');
                textureCanvas.width = textureWidth;
                textureCanvas.height = textureHeight;
                const ctx = textureCanvas.getContext('2d');

                const texture = new THREE.CanvasTexture(textureCanvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.minFilter = THREE.LinearFilter;
                
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    side: THREE.DoubleSide,
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.set(-0.3, 0, 0);
                mesh.scale.set(1.25, 1.25, 1);
                scene.add(mesh);

                // --- CAMERA POSITION ---
                camera.position.set(0, 5, 12.5);
                camera.lookAt(0, 0, 0);

                // --- SCROLLING & ANIMATION STATE ---
                let scrollOffset = 0;
                const total3DHeight = slides * (slideHeight + slideGap);
                let scrollStopTimer;
                let targetCurveAmount = 1;
                let currentCurveAmount = 1;

                const FLATTEN_LERP_FACTOR = 0.4;
                const CURVE_LERP_FACTOR = 0.4;

                function updateGeometry(curveAmount) {
                    const positions = geometry.attributes.position.array;

                    for (let i = 0; i < positions.length; i++) {
                        positions[i] = originalPositions[i] + (curvedPositions[i] - originalPositions[i]) * curveAmount;
                    }
                    
                    geometry.attributes.position.needsUpdate = true;
                    geometry.computeVertexNormals();
                }

                function updateTexture(offset) {
                    ctx.clearRect(0, 0, textureCanvas.width, textureCanvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, textureCanvas.width, textureCanvas.height);

                    const totalSlidesToRender = slides + 3;
                    let viewCenter = (-offset * textureHeight) % textureHeight;
                    if (viewCenter < 0) viewCenter += textureHeight;

                    for (let i = -1; i < totalSlidesToRender - 1; i++) {
                        const slideIndex = ((i % slides) + slides) % slides;
                        const img = images[slideIndex];
                        
                        const singleSlideTextureHeight = (slideHeight + slideGap) / total3DHeight * textureHeight;
                        let yPos = (i * singleSlideTextureHeight + offset * textureHeight) % textureHeight;
                        if (yPos < 0) yPos += textureHeight;
                        
                        const dist = Math.min(Math.abs(yPos - viewCenter), textureHeight - Math.abs(yPos - viewCenter));
                        const maxBlurDistance = textureHeight / 3; 
                        const maxBlurAmount = 10; 
                        let blurAmount = (dist / maxBlurDistance) * maxBlurAmount;
                        blurAmount = Math.min(blurAmount, maxBlurAmount);

                        ctx.filter = `blur(${blurAmount}px)`;

                        const slideTextureHeight = slideHeight / total3DHeight * textureHeight;
                        const imgAspectRatio = img.width / img.height;
                        const slideSlotAspectRatio = textureWidth / slideTextureHeight;

                        let sx = 0, sy = 0, sWidth = img.width, sHeight = img.height;
                        let destX = 0, destY = yPos - slideTextureHeight / 2;
                        let destWidth = textureWidth, destHeight = slideTextureHeight;

                        // File-specific no-crop contain mode for known cut images
                        const src = imageSources[slideIndex] || '';
                        const useContain = src.includes('37DDCEE6-4261-41ED-9FE5-5CF17EB81538.jpeg') || src.includes('IMG_3909.jpg');

                        if (useContain) {
                            // Contain: fit entire image, letterbox as needed
                            const scale = Math.min(textureWidth / img.width, slideTextureHeight / img.height);
                            const destWidthContain = img.width * scale;
                            const destHeightContain = img.height * scale;
                            destX = (textureWidth - destWidthContain) / 2;
                            destY = yPos - slideTextureHeight / 2 + (slideTextureHeight - destHeightContain) / 2;
                            destWidth = destWidthContain;
                            destHeight = destHeightContain;
                            sx = 0; sy = 0; sWidth = img.width; sHeight = img.height;
                        } else {
                            // Default cover-like crop to fill slot
                            if (imgAspectRatio > slideSlotAspectRatio) {
                                // Image is wider than slot - fit to height, crop width
                                sHeight = img.height;
                                sWidth = img.height * slideSlotAspectRatio;
                                sx = (img.width - sWidth) / 2;
                                sy = 0;
                            } else {
                                // Image is taller than slot - fit to width, crop height
                                sWidth = img.width;
                                sHeight = img.width / slideSlotAspectRatio;
                                sx = 0;
                                sy = (img.height - sHeight) / 2;
                            }
                        }

                        if (!useContain) {
                            // Ensure we don't crop too aggressively - maintain minimum visible area
                            const minVisibleRatio = 0.7; // Show at least 70% of the image
                            if (sWidth / img.width < minVisibleRatio) {
                                sWidth = img.width * minVisibleRatio;
                                sx = Math.max(0, (img.width - sWidth) / 2);
                            }
                            if (sHeight / img.height < minVisibleRatio) {
                                sHeight = img.height * minVisibleRatio;
                                sy = Math.max(0, (img.height - sHeight) / 2);
                            }
                        }

                        ctx.drawImage(img, sx, sy, sWidth, sHeight, destX, destY, destWidth, destHeight);
                        ctx.filter = 'none';
                    }
                    texture.needsUpdate = true;
                }
                
                // --- MAIN ANIMATION LOOP ---
                function animate() {
                    let lerpFactor = targetCurveAmount < currentCurveAmount ? FLATTEN_LERP_FACTOR : CURVE_LERP_FACTOR;
                    currentCurveAmount += (targetCurveAmount - currentCurveAmount) * lerpFactor;

                    if (Math.abs(targetCurveAmount - currentCurveAmount) < 0.001) {
                        currentCurveAmount = targetCurveAmount;
                    }

                    updateGeometry(currentCurveAmount);
                    updateTexture(scrollOffset);
                    renderer.render(scene, camera);

                    requestAnimationFrame(animate);
                }

                // --- EVENT LISTENERS ---
                lenis.on('scroll', (e) => {
                    const section = document.getElementById('third');
                    const rect = section.getBoundingClientRect();
                    const sectionProgress = Math.max(0, Math.min(1, -rect.top / (rect.height - window.innerHeight)));
                    
                    scrollOffset = -sectionProgress;
                    targetCurveAmount = 1;

                    clearTimeout(scrollStopTimer);
                    scrollStopTimer = setTimeout(() => {
                        targetCurveAmount = 0;
                    }, 150);
                });

                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                });

                // --- START THE EXPERIENCE ---
                animate();
            };

            imageSources.forEach((src, index) => {
                const img = new Image();
                img.src = src;
                img.onload = () => {
                    imagesLoaded++;
                    if (imagesLoaded === imageSources.length) {
                        initSlider();
                    }
                };
                img.onerror = () => {
                    console.warn('Image failed to load:', src);
                    imagesLoaded++;
                    if (imagesLoaded === imageSources.length) {
                        initSlider();
                    }
                };
                images[index] = img;
            });
        }

        // ============= FOURTH SECTION ANIMATIONS =============
        function initFourthAnimations() {
            console.log('Fourth section animations started');
            const section = document.getElementById('fourth');
            const video = section.querySelector('.video-screen');
            const overlayHeading = section.querySelector('.video-heading');
            const soundToggle = document.getElementById('soundToggle');
            let hasInteracted = false;
            let videoStarted = false;

            section.classList.add('animate');

            // Enhanced video autoplay function for Safari compatibility
            const tryPlay = async (force = false) => {
                if (!video || (videoStarted && !force)) return;

                try {
                    // For Safari, we need to be more aggressive with autoplay settings
                    video.muted = true;
                    video.setAttribute('playsinline', '');
                    video.setAttribute('autoplay', '');
                    video.setAttribute('webkit-playsinline', '');
                    video.preload = 'metadata'; // Load metadata first for faster startup

                    if (!videoStarted) {
                        video.load();
                    }

                    const playPromise = video.play();
                    if (playPromise) {
                        await playPromise;
                        console.log('Video autoplay successful');
                        videoStarted = true;
                    }
                } catch (error) {
                    console.log('Video autoplay failed:', error);
                    // Don't retry automatically - wait for user interaction on Safari
                }
            };

            // Pre-load video metadata for faster startup
            const preloadVideo = () => {
                if (video && !videoStarted) {
                    video.preload = 'metadata';
                    video.load();
                }
            };

            // Initial preload and autoplay attempt
            preloadVideo();
            // Small delay before trying to play to ensure metadata is loaded
            setTimeout(() => tryPlay(), 100);

            // Force play on user interaction - this is the key for Safari
            const forcePlay = async (unmute = true) => {
                if (!video) return;

                try {
                    // Enable sound if requested (first interaction)
                    if (unmute) {
                        video.muted = false;
                        if (soundToggle) soundToggle.textContent = 'üîä';
                    }

                    // Ensure video plays
                    if (video.paused || !videoStarted) {
                        const playPromise = await video.play();
                        videoStarted = true;
                        console.log('Video started via user interaction');
                    }
                } catch (e) {
                    console.log('Force play failed:', e);
                    // Fallback: try muted play
                    try {
                        video.muted = true;
                        if (soundToggle) soundToggle.textContent = 'üîá';
                        await video.play();
                        videoStarted = true;
                    } catch (fallbackError) {
                        console.log('Fallback play also failed:', fallbackError);
                    }
                }
            };

            const onFirstInteract = async () => {
                if (hasInteracted) return;
                hasInteracted = true;

                // Stop following cursor and position button normally
                if (soundToggle) {
                    soundToggle.classList.remove('follow');
                    soundToggle.style.removeProperty('--fx');
                    soundToggle.style.removeProperty('--fy');
                }

                // Start video with sound enabled
                await forcePlay(true);

                // Clean up listeners
                section.removeEventListener('click', onFirstInteract);
                section.removeEventListener('touchstart', onFirstInteract);
                section.removeEventListener('mousemove', onMouseMove);
            };

            // Enhanced mouse move for better cursor following
            const onMouseMove = (e) => {
                if (hasInteracted || !soundToggle) return;

                const rect = section.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Ensure the toggle stays within the video container bounds
                const toggleRect = soundToggle.getBoundingClientRect();
                const maxX = rect.width - toggleRect.width;
                const maxY = rect.height - toggleRect.height;

                const clampedX = Math.max(0, Math.min(x, maxX));
                const clampedY = Math.max(0, Math.min(y, maxY));

                soundToggle.style.setProperty('--fx', clampedX + 'px');
                soundToggle.style.setProperty('--fy', clampedY + 'px');
            };

            // Add interaction listeners
            section.addEventListener('click', onFirstInteract);
            section.addEventListener('touchstart', onFirstInteract, { passive: true });
            section.addEventListener('mousemove', onMouseMove);

            // Heading animation
            setTimeout(() => {
                overlayHeading && overlayHeading.classList.add('show');
            }, 600);

            // Sound toggle setup
            if (soundToggle) {
                soundToggle.classList.add('follow');

                soundToggle.addEventListener('click', async (e) => {
                    e.stopPropagation(); // Prevent triggering section click

                    if (!hasInteracted) {
                        // First click - enable interaction and start video
                        await onFirstInteract();
                    } else {
                        // Subsequent clicks - just toggle sound
                        try {
                            video.muted = !video.muted;
                            soundToggle.textContent = video.muted ? 'üîá' : 'üîä';

                            // Ensure video is playing when unmuting
                            if (!video.muted && video.paused) {
                                await video.play();
                            }
                        } catch (error) {
                            console.log('Sound toggle error:', error);
                        }
                    }
                });
            }

            // Improved video pause/resume handling
            let wasPlayingBeforeHidden = false;

            const handleVisibilityChange = () => {
                if (document.hidden) {
                    // Store playing state and pause video when page becomes hidden
                    if (video && !video.paused && videoStarted) {
                        wasPlayingBeforeHidden = true;
                        video.pause();
                    }
                } else {
                    // Resume video immediately when page becomes visible (if it was playing before)
                    if (video && videoStarted && wasPlayingBeforeHidden) {
                        video.play().catch(e => {
                            console.log('Resume play failed:', e);
                            // Reset flag if resume fails
                            wasPlayingBeforeHidden = false;
                        });
                    }
                }
            };

            document.addEventListener('visibilitychange', handleVisibilityChange);
        }

        // ============= FINAL SECTION ANIMATIONS =============
        function initFinalAnimations() {
            console.log('Final section animations started');
            
            const canvas = document.getElementById('shader-canvas');
            if (!canvas || canvas.shaderInitialized) return;
            
            canvas.shaderInitialized = true;

            // --- SHADER BACKGROUND SETUP ---
            const vertexShader = `void main() { gl_Position = vec4(position, 1.0); }`;
            
            const fragmentShader = `
                uniform vec3 iResolution;
                uniform float iTime;
                uniform float iScroll;
                
                void mainImage( out vec4 o, vec2 I ) {
                    vec2 uv = (I - iResolution.xy * 0.5) / iResolution.y;
                    float dist = length(uv);
                    float time = iTime * 0.3 + iScroll * 4.0;
                    float z = 1.0 / (dist + 0.1) + time;
                    float rings = sin(z * 30.0) * 0.5 + 0.5;
                    float angle = atan(uv.y, uv.x);
                    float segments = sin(angle * 16.0) * 0.5 + 0.5;
                    float pattern = rings * segments;
                    float perspective = smoothstep(0.0, 1.5, dist);
                    pattern *= perspective;
                    float centerGlow = 1.0 / (dist * 3.0 + 0.1);
                    centerGlow = pow(centerGlow, 1.5);
                    float brightness = centerGlow * pattern;
                    float ultraCenter = exp(-dist * 8.0);
                    brightness += ultraCenter * 2.0;
                    float intensity = brightness;
                    intensity *= (1.0 - smoothstep(0.6, 1.0, dist));
                    intensity = clamp(intensity, 0.0, 3.0);
                    intensity = pow(intensity, 0.7);
                    o = vec4(intensity, intensity, intensity, 1.0);
                }
                
                void main() {
                    mainImage(gl_FragColor, gl_FragCoord.xy);
                }
            `;

            const scene = new THREE.Scene();
            const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: false });
            renderer.setClearColor(0x000000, 1);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            const uniforms = {
                iTime: { value: 0 },
                iResolution: { value: new THREE.Vector3() },
                iScroll: { value: 0.0 }
            };

            function updateResolution() {
                const canvas = renderer.domElement;
                uniforms.iResolution.value.set(canvas.width, canvas.height, 1);
            }

            const material = new THREE.ShaderMaterial({ vertexShader, fragmentShader, uniforms });
            const geometry = new THREE.PlaneGeometry(2, 2);
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            updateResolution();

            // --- IMAGE SLIDER LOGIC ---
            const sliderContainer = document.getElementById('finalSliderContainer');
            const photoList = [
                './3D Models/Photos/F0FC3AB0-E35E-4C2F-8E5F-957525F1C333_1_105_c.jpeg',
                './3D Models/Photos/37DDCEE6-4261-41ED-9FE5-5CF17EB81538.jpeg',
                './3D Models/Photos/IMG_3909.jpg',
                './3D Models/Photos/05A9ED6E-FA1A-48FC-8BBA-52EF813F86CF_1_105_c.jpeg',
                './3D Models/Photos/EE4AD704-BC7E-47BA-BC0C-2E79A4A85A21_1_105_c.jpeg',
                './3D Models/Photos/93F074D8-9B32-42F1-98D0-015AF7ACA07B_1_105_c.jpeg',
                './3D Models/Photos/498186987_1407760920228311_3657067735162639362_n.jpg',
                './3D Models/Photos/510740532_1434290240908712_4338572798055198302_n.jpg'
            ];

            // Create slides dynamically for all photos
            const wishIcons = ['üéâ','üåü','üéÇ','üíù','üèÜ','üåà','‚ú®','üí´'];
            const wishMessages = [
                'May this new year of your life be filled with endless joy, success, and the warmth of family love.',
                'Your wisdom, kindness, and strength inspire us every day. Here\'s to another year of your amazing journey!',
                'On this special day, we celebrate not just your birthday, but the incredible person you are to all of us.',
                'Your love has shaped our world in the most beautiful ways. Thank you for being our guiding light.',
                'May the year ahead bring you health, happiness, and all the dreams your heart desires.',
                'Today we celebrate you ‚Äî the most wonderful father, mentor, and friend. Here\'s to many more beautiful years!',
                'Every memory with you shines brighter than the last.','You make ordinary days extraordinary.'
            ];
            const wishSignatures = ['With love ‚ù§Ô∏è','Forever grateful üôè','Happy Birthday, Papa! üéä','With endless love üíï','Cheers to 47! ü•≥','Forever yours üíñ','Always with love ‚ù§Ô∏è','From all of us üíû'];

            sliderContainer.innerHTML = '';
            photoList.forEach((src, i) => {
                const slide = document.createElement('div');
                slide.className = 'slide';
                slide.dataset.wish = String(i % 6);
                slide.innerHTML = `
                    <div class="slide-inner">
                        <div class="slide-front">
                            <img src="${src}" alt="Memory ${i+1}">
                        </div>
                        <div class="slide-back">
                            <div class="wish-icon">${wishIcons[i % wishIcons.length]}</div>
                            <div class="wish-text">${wishMessages[i % wishMessages.length]}</div>
                            <div class="wish-signature">${wishSignatures[i % wishSignatures.length]}</div>
                        </div>
                    </div>`;
                sliderContainer.appendChild(slide);
            });

            const slides = sliderContainer.querySelectorAll('.slide');
            let currentScroll = 0;

            const clock = new THREE.Clock();
            
            function animate() {
                requestAnimationFrame(animate);
                uniforms.iTime.value = clock.getElapsedTime() * 0.5; 
                renderer.render(scene, camera);

                // Animate slides based on scroll
                const section = document.getElementById('final');
                const rect = section.getBoundingClientRect();
                const sectionProgress = Math.max(0, Math.min(1, -rect.top / (rect.height - window.innerHeight)));
                currentScroll = sectionProgress;
                uniforms.iScroll.value = currentScroll;

                const totalSlides = slides.length;
                slides.forEach((slide, index) => {
                    const slideStart = index / totalSlides;
                    const slideDuration = 1 / totalSlides;
                    const progress = (currentScroll - slideStart) / slideDuration;

                    if (progress >= 0 && progress <= 1) {
                        const zStart = -3000;
                        const zEnd = 800;
                        const z = zStart + (progress * (zEnd - zStart));
                        const xDirection = index % 2 === 0 ? 1 : -1;
                        const x = (window.innerWidth / 2) * 0.6 * xDirection;
                        const ease = Math.sin(progress * Math.PI);
                        const opacity = ease;
                        const scale = 0.7 + ease * 0.3;
                        
                        // Improve click interaction area for edge cards
                        const isNearEdge = Math.abs(x) > window.innerWidth * 0.25;
                        const clickableOpacity = isNearEdge ? Math.max(0.3, opacity) : opacity;

                        slide.style.opacity = opacity;
                        slide.style.transform = `translate3d(${x}px, 0px, ${z}px) scale(${scale})`;
                        
                        // Ensure cards remain clickable even at edges
                        slide.style.pointerEvents = clickableOpacity > 0.1 ? 'auto' : 'none';
                        
                        // Add higher z-index for cards closer to camera
                        slide.style.zIndex = Math.round(1000 + z);
                    } else {
                        slide.style.opacity = 0;
                        slide.style.pointerEvents = 'none';
                    }
                });
            }

            window.addEventListener('resize', () => {
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                updateResolution();
            });

            animate();
            
            // ============= CARD INTERACTION SYSTEM =============
            setupCardInteractions();
        }
        
        function setupCardInteractions() {
            const slides = document.querySelectorAll('#final .slide');
            const backdrop = document.getElementById('cardBackdrop');
            let activeCard = null;
            
            slides.forEach((slide, index) => {
                slide.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    if (activeCard === slide) {
                        // Close if clicking the same card
                        closeCard();
                        return;
                    }
                    
                    // Close any other active card first
                    if (activeCard) {
                        closeCard();
                    }
                    
                    // Open this card
                    openCard(slide);
                });
            });
            
            // Close card when clicking backdrop
            backdrop.addEventListener('click', closeCard);
            
            // Close card with Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && activeCard) {
                    closeCard();
                }
            });
            
            function openCard(slide) {
                activeCard = slide;
                
                // Show backdrop with minimal interference
                backdrop.classList.add('active');
                
                // Store original transform and override with centered position
                slide.dataset.originalTransform = slide.style.transform;
                slide.dataset.originalOpacity = slide.style.opacity;
                slide.dataset.originalZIndex = slide.style.zIndex;
                
                // Center and flip the card
                slide.classList.add('centered', 'flipped');
                
                // Disable other slides interaction temporarily
                slides.forEach(s => {
                    if (s !== slide) {
                        s.style.pointerEvents = 'none';
                    }
                });
                
                // Add gentle bounce effect
                setTimeout(() => {
                    if (activeCard === slide) {
                        slide.style.transform = slide.style.transform.replace('scale(1.2)', 'scale(1.25)');
                        setTimeout(() => {
                            if (activeCard === slide) {
                                slide.style.transform = slide.style.transform.replace('scale(1.25)', 'scale(1.2)');
                            }
                        }, 150);
                    }
                }, 500);
            }
            
            function closeCard() {
                if (!activeCard) return;
                
                const cardToClose = activeCard;
                
                // Hide backdrop
                backdrop.classList.remove('active');
                
                // Reset the card
                cardToClose.classList.remove('centered');
                
                // Restore original positioning
                if (cardToClose.dataset.originalTransform) {
                    cardToClose.style.transform = cardToClose.dataset.originalTransform;
                }
                if (cardToClose.dataset.originalOpacity) {
                    cardToClose.style.opacity = cardToClose.dataset.originalOpacity;
                }
                if (cardToClose.dataset.originalZIndex) {
                    cardToClose.style.zIndex = cardToClose.dataset.originalZIndex;
                }
                
                // Flip back to front after a delay
                setTimeout(() => {
                    if (cardToClose) {
                        cardToClose.classList.remove('flipped');
                        // Clean up stored data
                        delete cardToClose.dataset.originalTransform;
                        delete cardToClose.dataset.originalOpacity;
                        delete cardToClose.dataset.originalZIndex;
                    }
                }, 300);
                
                // Re-enable all slides interaction
                setTimeout(() => {
                    slides.forEach(s => {
                        s.style.pointerEvents = 'auto';
                    });
                    activeCard = null;
                }, 800);
            }
        }

        // ============= LAST FINAL SECTION ANIMATIONS =============
        function initLastFinalAnimations() {
            console.log('Last final section animations started');
            
            const canvas = document.getElementById('fireworks-canvas');
            if (!canvas || canvas.fireworksInitialized) return;
            
            canvas.fireworksInitialized = true;

            const ctx = canvas.getContext('2d');
            let w = (canvas.width = window.innerWidth);
            let h = (canvas.height = window.innerHeight);
            let hw = w / 2;
            let hh = h / 2;

            const opts = {
                strings: ['HAPPY', 'BIRTHDAY!', 'Lovely Papa'],
                charSize: 30,
                charSpacing: 35,
                lineHeight: 40,
                charWeight: '700',
                cx: w / 2,
                cy: h / 2,
                fireworkPrevPoints: 10,
                fireworkBaseLineWidth: 5,
                fireworkAddedLineWidth: 8,
                fireworkSpawnTime: 200,
                fireworkBaseReachTime: 30,
                fireworkAddedReachTime: 30,
                fireworkCircleBaseSize: 20,
                fireworkCircleAddedSize: 10,
                fireworkCircleBaseTime: 30,
                fireworkCircleAddedTime: 30,
                fireworkCircleFadeBaseTime: 10,
                fireworkCircleFadeAddedTime: 5,
                fireworkBaseShards: 5,
                fireworkAddedShards: 5,
                fireworkShardPrevPoints: 3,
                fireworkShardBaseVel: 4,
                fireworkShardAddedVel: 2,
                fireworkShardBaseSize: 3,
                fireworkShardAddedSize: 3,
                gravity: 0.1,
                upFlow: -0.1,
                letterContemplatingWaitTime: 360,
                balloonSpawnTime: 20,
                balloonBaseInflateTime: 10,
                balloonAddedInflateTime: 10,
                balloonBaseSize: 20,
                balloonAddedSize: 20,
                balloonBaseVel: 0.4,
                balloonAddedVel: 0.4,
                balloonBaseRadian: -(Math.PI / 2 - 0.5),
                balloonAddedRadian: -1
            };

            const calc = {
                totalWidth: opts.charSpacing * Math.max(opts.strings[0].length, opts.strings[1].length)
            };
            const Tau = Math.PI * 2;
            const TauQuarter = Tau / 4;
            let letters = [];
            let finished = false;
            let particles = [];

            // Set responsive sizes
            function setResponsiveSizes() {
                const base = Math.min(w, h);
                opts.charSize = Math.max(28, Math.round(base * 0.1));
                opts.charSpacing = Math.round(opts.charSize * 1.18);
                opts.lineHeight = Math.round(opts.charSize * 1.38);
                ctx.font = opts.charWeight + ' ' + opts.charSize + 'px "Space Grotesk", sans-serif';
                calc.totalWidth = opts.charSpacing * Math.max(opts.strings[0].length, opts.strings[1].length);
            }
            setResponsiveSizes();

            function drawBackground() {
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                const g = ctx.createLinearGradient(0, 0, w, h);
                g.addColorStop(0, '#050506');
                g.addColorStop(1, '#0a0a0c');
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, w, h);
            }

            function buildParticles() {
                particles = [];
                const targetCount = Math.max(24, Math.round((w * h) / 60000));
                for (let i = 0; i < targetCount; i++) {
                    const r = Math.random() * 10 + 6;
                    particles.push({
                        x: Math.random() * w,
                        y: Math.random() * h,
                        vx: (Math.random() * 2 - 1) * 0.6,
                        vy: (Math.random() * 2 - 1) * 0.6,
                        r: r,
                        a: Math.random() * 0.4 + 0.3,
                        pulse: Math.random() * Math.PI * 2
                    });
                }
            }

            function stepParticles() {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                for (let i = 0; i < particles.length; i++) {
                    const p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    
                    // Bounce on edges
                    if (p.x < p.r) { p.x = p.r; p.vx *= -1; }
                    if (p.x > w - p.r) { p.x = w - p.r; p.vx *= -1; }
                    if (p.y < p.r) { p.y = p.r; p.vy *= -1; }
                    if (p.y > h - p.r) { p.y = h - p.r; p.vy *= -1; }

                    p.pulse += 0.02;
                    const alpha = p.a + Math.sin(p.pulse) * 0.12;

                    const rad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 1.4);
                    rad.addColorStop(0, 'rgba(255,255,255,' + Math.max(0, alpha) + ')');
                    rad.addColorStop(0.5, 'rgba(255,255,255,' + Math.max(0, alpha * 0.55) + ')');
                    rad.addColorStop(1, 'rgba(255,255,255,0)');

                    ctx.shadowColor = 'rgba(255,255,255,' + Math.max(0, alpha * 0.8) + ')';
                    ctx.shadowBlur = Math.round(p.r * 1.8);
                    ctx.fillStyle = rad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r, 0, Tau);
                    ctx.fill();
                }
                ctx.restore();
            }

            function Letter(char, x, y) {
                this.char = char;
                this.x = x;
                this.y = y;
                this.dx = -ctx.measureText(char).width / 2;
                this.dy = +opts.charSize / 2;
                this.fireworkDy = this.y - hh;
                const hue = (x / calc.totalWidth) * 360;
                this.color = 'hsl(' + hue + ',80%,50%)';
                this.lightAlphaColor = 'hsla(' + hue + ',80%,light%,alp)';
                this.lightColor = 'hsl(' + hue + ',80%,light%)';
                this.alphaColor = 'hsla(' + hue + ',80%,50%,alp)';
                this.reset();
            }

            Letter.prototype.reset = function () {
                this.phase = 'firework';
                this.tick = 0;
                this.spawned = false;
                this.spawningTime = (opts.fireworkSpawnTime * Math.random()) | 0;
                this.reachTime = (opts.fireworkBaseReachTime + opts.fireworkAddedReachTime * Math.random()) | 0;
                this.lineWidth = opts.fireworkBaseLineWidth + opts.fireworkAddedLineWidth * Math.random();
                this.prevPoints = [[0, hh, 0]];
            };

            Letter.prototype.step = function () {
                if (this.phase === 'firework') {
                    if (!this.spawned) {
                        ++this.tick;
                        if (this.tick >= this.spawningTime) {
                            this.tick = 0;
                            this.spawned = true;
                        }
                    } else {
                        ++this.tick;
                        const linearProportion = this.tick / this.reachTime;
                        const armonicProportion = Math.sin(linearProportion * TauQuarter);
                        const x = linearProportion * this.x;
                        const y = hh + armonicProportion * this.fireworkDy;
                        
                        if (this.prevPoints.length > opts.fireworkPrevPoints) this.prevPoints.shift();
                        this.prevPoints.push([x, y, linearProportion * this.lineWidth]);
                        
                        const lineWidthProportion = 1 / (this.prevPoints.length - 1);
                        for (let i = 1; i < this.prevPoints.length; ++i) {
                            const point = this.prevPoints[i];
                            const point2 = this.prevPoints[i - 1];
                            ctx.strokeStyle = this.alphaColor.replace('alp', i / this.prevPoints.length);
                            ctx.lineWidth = point[2] * lineWidthProportion * i;
                            ctx.beginPath();
                            ctx.moveTo(point[0], point[1]);
                            ctx.lineTo(point2[0], point2[1]);
                            ctx.stroke();
                        }
                        
                        if (this.tick >= this.reachTime) {
                            this.phase = 'contemplate';
                            this.circleFinalSize = opts.fireworkCircleBaseSize + opts.fireworkCircleAddedSize * Math.random();
                            this.circleCompleteTime = (opts.fireworkCircleBaseTime + opts.fireworkCircleAddedTime * Math.random()) | 0;
                            this.circleCreating = true;
                            this.circleFading = false;
                            this.circleFadeTime = (opts.fireworkCircleFadeBaseTime + opts.fireworkCircleFadeAddedTime * Math.random()) | 0;
                            this.tick = 0;
                            this.tick2 = 0;
                            this.shards = [];
                            
                            const shardCount = (opts.fireworkBaseShards + opts.fireworkAddedShards * Math.random()) | 0;
                            const angle = Tau / shardCount;
                            const cos = Math.cos(angle);
                            const sin = Math.sin(angle);
                            let x = 1, y = 0;
                            
                            for (let i = 0; i < shardCount; ++i) {
                                const x1 = x;
                                x = x * cos - y * sin;
                                y = y * cos + x1 * sin;
                                this.shards.push(new Shard(this.x, this.y, x, y, this.alphaColor));
                            }
                        }
                    }
                } else if (this.phase === 'contemplate') {
                    ++this.tick;
                    if (this.circleCreating) {
                        ++this.tick2;
                        const proportion = this.tick2 / this.circleCompleteTime;
                        const armonic = -Math.cos(proportion * Math.PI) / 2 + 0.5;
                        ctx.beginPath();
                        ctx.fillStyle = this.lightAlphaColor
                            .replace('light', 50 + 50 * proportion)
                            .replace('alp', proportion);
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, armonic * this.circleFinalSize, 0, Tau);
                        ctx.fill();
                        if (this.tick2 > this.circleCompleteTime) {
                            this.tick2 = 0;
                            this.circleCreating = false;
                            this.circleFading = true;
                        }
                    } else if (this.circleFading) {
                        ctx.save();
                        ctx.shadowColor = this.lightColor.replace('light', 65);
                        ctx.shadowBlur = Math.round(opts.charSize * 0.35);
                        ctx.fillStyle = this.lightColor.replace('light', 82);
                        ctx.fillText(this.char, this.x + this.dx, this.y + this.dy);
                        ctx.restore();
                        ++this.tick2;
                        const proportion = this.tick2 / this.circleFadeTime;
                        const armonic = -Math.cos(proportion * Math.PI) / 2 + 0.5;
                        ctx.beginPath();
                        ctx.fillStyle = this.lightAlphaColor.replace('light', 100).replace('alp', 1 - armonic);
                        ctx.arc(this.x, this.y, this.circleFinalSize, 0, Tau);
                        ctx.fill();
                        if (this.tick2 >= this.circleFadeTime) this.circleFading = false;
                    } else {
                        ctx.save();
                        ctx.shadowColor = this.lightColor.replace('light', 60);
                        ctx.shadowBlur = Math.round(opts.charSize * 0.35);
                        ctx.fillStyle = this.lightColor.replace('light', 82);
                        ctx.fillText(this.char, this.x + this.dx, this.y + this.dy);
                        ctx.restore();
                    }
                    
                    for (let i = 0; i < this.shards.length; ++i) {
                        this.shards[i].step();
                        if (!this.shards[i].alive) {
                            this.shards.splice(i, 1);
                            --i;
                        }
                    }
                    
                    if (this.tick > opts.letterContemplatingWaitTime) {
                        this.phase = 'balloon';
                        this.tick = 0;
                        this.spawning = true;
                        this.spawnTime = (opts.balloonSpawnTime * Math.random()) | 0;
                        this.inflating = false;
                        this.inflateTime = (opts.balloonBaseInflateTime + opts.balloonAddedInflateTime * Math.random()) | 0;
                        this.size = (opts.balloonBaseSize + opts.balloonAddedSize * Math.random()) | 0;
                        const rad = opts.balloonBaseRadian + opts.balloonAddedRadian * Math.random();
                        const vel = opts.balloonBaseVel + opts.balloonAddedVel * Math.random();
                        this.vx = Math.cos(rad) * vel;
                        this.vy = Math.sin(rad) * vel;
                    }
                } else if (this.phase === 'balloon') {
                    ctx.strokeStyle = this.lightColor.replace('light', 80);
                    if (this.spawning) {
                        ++this.tick;
                        ctx.fillStyle = this.lightColor.replace('light', 70);
                        ctx.fillText(this.char, this.x + this.dx, this.y + this.dy);
                        if (this.tick >= this.spawnTime) {
                            this.tick = 0;
                            this.spawning = false;
                            this.inflating = true;
                        }
                    } else if (this.inflating) {
                        ++this.tick;
                        const proportion = this.tick / this.inflateTime;
                        const x = (this.cx = this.x);
                        const y = (this.cy = this.y - this.size * proportion);
                        ctx.fillStyle = this.alphaColor.replace('alp', proportion);
                        ctx.beginPath();
                        generateBalloonPath(x, y, this.size * proportion);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x, this.y);
                        ctx.stroke();
                        ctx.fillStyle = this.lightColor.replace('light', 70);
                        ctx.fillText(this.char, this.x + this.dx, this.y + this.dy);
                        if (this.tick >= this.inflateTime) {
                            this.tick = 0;
                            this.inflating = false;
                        }
                    } else {
                        this.cx += this.vx;
                        this.cy += (this.vy += opts.upFlow);
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        generateBalloonPath(this.cx, this.cy, this.size);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(this.cx, this.cy);
                        ctx.lineTo(this.cx, this.cy + this.size);
                        ctx.stroke();
                        ctx.save();
                        ctx.shadowColor = this.lightColor.replace('light', 55);
                        ctx.shadowBlur = Math.round(opts.charSize * 0.3);
                        ctx.fillStyle = this.lightColor.replace('light', 85);
                        ctx.fillText(this.char, this.cx + this.dx, this.cy + this.dy + this.size);
                        ctx.restore();
                        if (this.cy + this.size < -hh || this.cx < -hw || this.cy > hw) this.phase = 'done';
                    }
                }
            };

            function Shard(x, y, vx, vy, color) {
                const vel = opts.fireworkShardBaseVel + opts.fireworkShardAddedVel * Math.random();
                this.vx = vx * vel;
                this.vy = vy * vel;
                this.x = x;
                this.y = y;
                this.prevPoints = [[x, y]];
                this.color = color;
                this.alive = true;
                this.size = opts.fireworkShardBaseSize + opts.fireworkShardAddedSize * Math.random();
            }

            Shard.prototype.step = function () {
                this.x += this.vx;
                this.y += (this.vy += opts.gravity);
                if (this.prevPoints.length > opts.fireworkShardPrevPoints) this.prevPoints.shift();
                this.prevPoints.push([this.x, this.y]);
                const lineWidthProportion = this.size / this.prevPoints.length;
                for (let k = 0; k < this.prevPoints.length - 1; ++k) {
                    const point = this.prevPoints[k];
                    const point2 = this.prevPoints[k + 1];
                    ctx.strokeStyle = this.color.replace('alp', k / this.prevPoints.length);
                    ctx.lineWidth = k * lineWidthProportion;
                    ctx.beginPath();
                    ctx.moveTo(point[0], point[1]);
                    ctx.lineTo(point2[0], point2[1]);
                    ctx.stroke();
                }
                if (this.prevPoints[0][1] > hh) this.alive = false;
            };

            function generateBalloonPath(x, y, size) {
                ctx.moveTo(x, y);
                ctx.bezierCurveTo(x - size / 2, y - size / 2, x - size / 4, y - size, x, y - size);
                ctx.bezierCurveTo(x + size / 4, y - size, x + size / 2, y - size / 2, x, y);
            }

            function buildLetters() {
                letters = [];
                for (let i = 0; i < opts.strings.length; ++i) {
                    for (let j = 0; j < opts.strings[i].length; ++j) {
                        letters.push(
                            new Letter(
                                opts.strings[i][j],
                                j * opts.charSpacing + opts.charSpacing / 2 - (opts.strings[i].length * opts.charSpacing) / 2,
                                i * opts.lineHeight + opts.lineHeight / 2 - (opts.strings.length * opts.lineHeight) / 2
                            )
                        );
                    }
                }
            }

            function animate() {
                drawBackground();
                stepParticles();
                if (!finished) {
                    ctx.translate(hw, hh);
                    let done = true;
                    for (let l = 0; l < letters.length; ++l) {
                        letters[l].step();
                        if (letters[l].phase !== 'done') done = false;
                    }
                    ctx.translate(-hw, -hh);
                    if (done) {
                        finished = true;
                    }
                }
                requestAnimationFrame(animate);
            }

            buildLetters();
            drawBackground();
            buildParticles();
            animate();

            window.addEventListener('resize', () => {
                w = canvas.width = window.innerWidth;
                h = canvas.height = window.innerHeight;
                hw = w / 2;
                hh = h / 2;
                setResponsiveSizes();
                buildLetters();
                finished = false;
                drawBackground();
                buildParticles();
            });
        }

        // ============= THROTTLED SCROLL HANDLER =============
        let scrollTicking = false;
        
        function handleScroll() {
            if (!scrollTicking) {
                requestAnimationFrame(() => {
                    updateScrollProgress();
                    updateScrollIndicator();
                    updateActiveSection();
                    scrollTicking = false;
                });
                scrollTicking = true;
            }
            
            if (!isScrolling) {
                isScrolling = true;
            }
            
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                isScrolling = false;
            }, 150);
        }

        // ============= EVENT LISTENERS =============
        lenis.on('scroll', handleScroll);

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                calculateSectionBounds();
                updateActiveSection();
            }, 100);
        });

        // ============= INITIALIZATION =============
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Birthday experience initialized');
            calculateSectionBounds();
            updateActiveSection();
            initHeroAnimations(); // Start with hero animations
        });
    </script>
</body>
</html>
